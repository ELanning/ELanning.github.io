<!DOCTYPE html>
<html>
<head><title>The Big-O of Code</title></head>
<body>
<h1 id="the-big-o-of-maintenance">The Big-O of Maintenance</h1>
<p>A large part of a projects lifetime is maintenance, with estimates at 60% to 80%.ยน That statistic defines maintenance as fixing bugs, and adding new functionality to an existing system.
With so much time spent on this phase, it&#39;s important to keep in mind: code itself grows and changes with respect to Big-O notation.</p>
<p>If adding a new features requires all modules to add a new reference, that&#39;s <code>O(n)</code>.
If adding a new feature requires one module to add one new reference, that&#39;s <code>O(1)</code>. Not bad.
If adding a new feature requires one module to add one new reference, but it&#39;s a massive &quot;kitchen sink&quot; module: probably not good.</p>
<p>This is a laid back and informal use of Big-O, but it gets the point across. If code is setup such that most changes are <code>O(1)</code>, much pain can be prevented.</p>
<p>I am also being loosey-goosey with what a &quot;module&quot; and &quot;reference&quot; is, that&#39;s on purpose. The interpretation is context and project dependent, but you&#39;ll know it when you see it.</p>
<p>Take for example this bit of pseudo-code,</p>
<pre><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">doSomeCoolStuff</span>(<span class="hljs-params">Comment comment</span>) </span>{
    ...
    <span class="hljs-built_in">string</span> <span class="hljs-built_in">url</span>;
    <span class="hljs-keyword">switch</span> (comment.kind)
        <span class="hljs-string">"baz"</span>: <span class="hljs-built_in">url</span> = <span class="hljs-string">"https://foo.com"</span>,
        <span class="hljs-string">"bop"</span>: <span class="hljs-built_in">url</span> = <span class="hljs-string">"https://bop.com"</span>,
        ...
    ...
}
</code></pre><p>We can immediately see, every time a new comment kind is added, this code likely needs to be <em>maintained</em>. If there&#39;s <code>n</code> different switch statements throughout the codebase, that&#39;s <code>n</code> different places to update.
It is worth mentioning, there is nothing inherently wrong with switch statements like these. They&#39;re normally straightforward, simple, and maintainable, but sometimes the alternatives are better.</p>
<p>There are a few immediate (among many) ways to &quot;extract&quot; this switch out, such that future updates may only require changing one place.</p>
<ol>
<li>A simple function approach. Just move the code into a shared function somewhere.</li>
</ol>
<pre><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">doSomeCoolStuff</span>(<span class="hljs-params">Comment comment</span>) </span>{
    ...
    <span class="hljs-built_in">string</span> <span class="hljs-built_in">url</span> = getUrl(comment.kind);
    ...
}
</code></pre><ol>
<li>A function passing approach. Function passing is a great way to create flexibility and move logic elsewhere.</li>
</ol>
<pre><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">doSomeCoolStuff</span>(<span class="hljs-params">Comment comment, Lambda getUrl</span>) </span>{
    ...
    <span class="hljs-built_in">string</span> <span class="hljs-built_in">url</span> = getUrl();
    ...
}
</code></pre><ol>
<li>A polymorphism/interface approach. Also a valid option that makes good sense in some situations.</li>
</ol>
<pre><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">doSomeCoolStuff</span>(<span class="hljs-params">Comment comment</span>) </span>{
    ...
    <span class="hljs-built_in">string</span> <span class="hljs-built_in">url</span> = comment.getUrl(); <span class="hljs-comment">// Changes based on the underlying implementation, eg `PostComment`, `NewsFeedComment`, etc.</span>
    ...
}
</code></pre><p>All we&#39;ve done is move complexity around. Sometimes this is all it takes to reduce overall complexity. If all of these <code>switch</code> statements are moved to one central place, we can get a big win by having updates only change one place. More so if it reduces some duplication, or allows us to calculate some value only once.</p>
<p>Related concepts: <a href="http://www.catb.org/~esr/writings/taoup/html/ch04s02.html#spot_rule">DRY</a>, <a href="https://wiki.c2.com/?SingleResponsibilityPrinciple">SRP</a>, <a href="https://wiki.c2.com/?DependencyInversionPrinciple">DIP</a>.</p>
<p>ยน Facts and Fallacies of Software Engineering (2002)</p>
</body>
</html>